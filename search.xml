<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[make快速入门]]></title>
    <url>%2F2018%2F11%2F14%2Fmake%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[make做什么大型项目为了方便维护和书写，拆分为大量的源文件和头文件。makefile告诉make如何编译、链接。当重新编译时只需重新编译改变的文件即可，当一个头文件修改后，依赖该头文件的源文件需要重新编译 make帮助手册的一个实例1234567891011121314151617181920212223edit : main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o main.o : main.c defs.h cc -c main.c kbd.o : kbd.c defs.h command.h cc -c kbd.c command.o : command.c defs.h command.h cc -c command.c display.o : display.c defs.h buffer.h cc -c display.c insert.o : insert.c defs.h buffer.h cc -c insert.c search.o : search.c defs.h buffer.h cc -c search.c files.o : files.c defs.h buffer.h command.h cc -c files.c utils.o : utils.c defs.h cc -c utils.c clean : rm edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o 对应的森林makefile可以理解成数据结构中的森林。 makefile由一系列规则组成，规则的格式如下：12target ... : prerequisites ... recipe prerequisites是本规则的依赖。recipe一些列命令，用于产生target。 简化为函数形式为123456func(pre1, pre2, ...) recipe1 recipe2 ... recipen return target 也可以没有依赖和返回12345func() recipe1 recipe2 ... recipen 执行make的流程 类似二叉树的后续遍历 先访问edit, 发现有依赖，继续访问main.o,有依赖，继续访问main.c，没有依赖。再访问defs.h没有依赖。访问main.o。比较main.o和main.c、defs.h的修改时间。如果main.c或者defs.h的修改时间大于main.o。则执行main.o中的脚本 cc -c main.c。否则继续使用main.o 继续访问utils.o。发现有依赖，继续访问utils.c，无依赖。访问defs.h无依赖。如果utils.c和defs.h的修改时间有大于utils.o则执行utils.o的脚本cc -c utils.c。否则继续使用utils.o 访问edit节点，如果main.o … utils.o的修改时间大于edit的时间。则执行cc -o edit main.o … utils.o。否则继续使用edit。 执行make clean的流程make无依赖，直接执行recipe就可。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcc常见参数整理]]></title>
    <url>%2F2018%2F11%2F14%2Fgcc%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[make约定俗成的规范： 1,首先从源代码生成目标文件(预处理,编译,汇编)，”-c”选项表示不执行链接步骤。$(CC) $(CPPFLAGS) $(CFLAGS) example.c -c -o example.o 2,然后将目标文件连接为最终的结果(连接)，”-o”选项用于指定输出文件的名字。$(CC) $(LDFLAGS) example.o -o example 有一些软件包一次完成四个步骤：$(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) example.c -o example CFLAGS 与 CXXFLAGSCFLAGS 表示用于 C 编译器的选项，CXXFLAGS 表示用于 C++ 编译器的选项。这两个变量实际上涵盖了编译和汇编两个步骤。大多数程序和库在编译时默认的优化级别是”2″(使用”-O2″选项)并且带有调试符号来编 译，也就是 CFLAGS=”-O2 -g”, CXXFLAGS=$CFLAGS 。事实上，”-O2″已经启用绝大多数安全的优化选项了。另一方面，由于大部分选项可以同时用于这两个变量，所以仅在最后讲述只能用于其中一个变量的选 项。[提醒]下面所列选项皆为非默认选项，你只要按需添加即可。 LDFLAGSld用于指定链接时参数 gcc参数解释编译 c 编译 Wall 最常用到的编译警告, 推荐总是使用该选项 o 小写字母o指定结果文件名称 l 链接库。编译器选项“-lNAME”试图链接标准库目录下的文件名为“libNAME.a”。lm =&gt; libm.a; I 指定头文件搜索路径 L 库搜索路径 static 使用静态库 ansi禁止那些与 ANSI/ISO 标准冲突的 GNU 扩展特性。在使用 GNU C 库(glibc) 的系统上，该选项也禁止了对 C 标准库的扩展。 std 指定标准, c89,c99,gnu99,gnu89 W常见潜在编程错误，建议开发时使用 预处理 D -DNAME选项在命令行上定义预处理宏 NAME E 预处理源文件 调试 g 存储额外的调试信息 优化 O0 或者无-O选项: 无优化 O1或者O: 不需要任何速度-空间折衷的最常见形式的优化 O2、03:更近异步优化 平台相关 march=CPU, 速度快，不可移植。–march=pentium4 动态链接一个与共享库链接的可执行文件仅仅包含它用到的函数相关的一个表格，而不是外部函数所在的 对象文件的整个机器码。在可执行文件开始运行以前，外部函数的机器码由操作系统从磁盘上的 该共享库中复制到内存中—-这个过程被称作动态链接 变量 LD_LIBRARY_PATH 动态库查找路径 C_INCLUDE_PATH 头文件查找路径 LIBRARY_PATH 静态查找路径]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo搭建博客]]></title>
    <url>%2F2018%2F11%2F13%2F%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[使用github page来托管我们的博客内容。文章的书写格式为markdown。使用hexo完成markdown到html的转换, 使用hexo deploy发布到github page上。 相关名词 markdown John Gruber在2004年发明了markdown, markdown易写易读,使用工具可以方便的转换为html等格式。 github page github page提供静态页面服务, 程序员不仅可以分享代码, 还可以写技术文章。 hexo nodejs开发的工具，用来把markdown转换为html静态网站 hexo安装步骤 安装nodejs brew install nodejs 安装hexo npm i -g hexo 初始化根目录 mkdir blog &amp;&amp; cd blog &amp;&amp; hexo init 安装git部署插件 npm install hexo-deployer-git --save 切换主题(可选)1234git clone https://github.com/wzpan/hexo-theme-freemind.git themes/freemind &amp;&amp; \npm install hexo-tag-bootstrap --save &amp;&amp; \npm install hexo-generator-search --save &amp;&amp; \npm install hexo-recommended-posts --save 修改_config.yml, 切换主题 sed -i &#39;s/^theme:.*/theme: freemind/g&#39; _config.yml hexo 使用步骤创建文章（正式文章或者草稿，使用markdown工具进行书写，书写完成后转换为html格式后进行发布。在书写工程中也可以在执行hexo gen &amp;&amp; hexo server后访问localhost:4000预览效果。 命令参考 创建草稿 hexo new draft 标题 发布草稿成为正式文章 hexo publish 标题 创建正式文章 hexo new 标题 使用文本工具进行写作, 如使用vim编辑 vim 标题 转换markdown到静态文件 hexo gen 预览网站效果 hexo server 发布到github page hexo deploy 清空生成文件 hexo clean hexo部署方案我希望markdown源文件和hexo生成的静态文件完全隔离。可以方便随时切换主题甚至工具，我只关心源markdown文件。所以设置两个仓库，一个保存hexo生成的html, 一个包含源markdown文件及配置文件。使用ln建立链接。算是linux下的kiss原则吧。我使用 blog和zhoupro.github.io 来搭建博客。 简化流程blog中的init.sh脚本把以上步骤自动化, 执行 . ./init.sh后直接写作即可。 图片处理参考上传图片到github，创建自己的github仓库，然后配置下脚本 curl https://gist.githubusercontent.com/zhoupro/e09657196114420d63218ebe77079d05/raw/c6d3bd4d8d3dc342813ae37de4e3aed652f9ac30/sh -o genUrl.sh &amp;&amp; bash genUrl.sh yourpic。你也可以上传到第三方服务，使用它们生成的链接。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[valgrind生成调用链]]></title>
    <url>%2F2018%2F11%2F12%2Fvalgrind%E7%94%9F%E6%88%90%E8%B0%83%E7%94%A8%E9%93%BE%2F</url>
    <content type="text"><![CDATA[valgrind查看调用关系在学习开源代码时，我们希望有个工具能够给我们全局的视角而不过早的陷入细节的泥淖中。读书可以跳读，读代码也是可以跳读的。valgrind可以生成整个调用关系链。该关系链指导我们，迅速定位到我们关心的细节。 安装ubuntu系统12apt-get install valgrind apt-get install kcachegrind mac系统1brew install qcachegrind --with-graphviz 使用 使用valgrind生成调用关系 1valgrind --tool=callgrind --trace-children=yes --callgrind-out-file=/data/opt/callgrind.out.1111 ./nginx 使用qcachegrind查看调用关系 问题 Error: can not open cache simulation output file保证写的目录有写的权限，可以创建一个目录，赋值为777，在该目录下启动命令valgrind --tool=callgrind --trace-children=yes /data/server/nginx/sbin/nginx, 使用kill终止程序kill SIGINT pid]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>valgrind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog purpose]]></title>
    <url>%2F2018%2F11%2F06%2Fblog%2F</url>
    <content type="text"><![CDATA[目的从2014年开始就折腾自己的个人博客，断断续续，从现在开始使用github来写自己的个人博客，用来记录自己的学习过程，把博客和折腾分开。专心学习。]]></content>
      <categories>
        <category>目标</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
