<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>gcc常见参数整理</title>
      <link href="/2018/11/14/gcc%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E6%95%B4%E7%90%86/"/>
      <url>/2018/11/14/gcc%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="make约定俗成的规范："><a href="#make约定俗成的规范：" class="headerlink" title="make约定俗成的规范："></a>make约定俗成的规范：</h3><ul><li>1,首先从源代码生成目标文件(预处理,编译,汇编)，”-c”选项表示不执行链接步骤。<br><code>$(CC) $(CPPFLAGS) $(CFLAGS) example.c   -c   -o example.o</code></li><li>2,然后将目标文件连接为最终的结果(连接)，”-o”选项用于指定输出文件的名字。<br><code>$(CC) $(LDFLAGS) example.o   -o example</code></li><li>有一些软件包一次完成四个步骤：<br><code>$(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) example.c   -o example</code></li></ul><h3 id="CFLAGS-与-CXXFLAGS"><a href="#CFLAGS-与-CXXFLAGS" class="headerlink" title="CFLAGS 与 CXXFLAGS"></a>CFLAGS 与 CXXFLAGS</h3><p>CFLAGS 表示用于 C 编译器的选项，CXXFLAGS 表示用于 C++ 编译器的选项。这两个变量实际上涵盖了编译和汇编两个步骤。大多数程序和库在编译时默认的优化级别是”2″(使用”-O2″选项)并且带有调试符号来编 译，也就是 CFLAGS=”-O2 -g”, CXXFLAGS=$CFLAGS 。事实上，”-O2″已经启用绝大多数安全的优化选项了。另一方面，由于大部分选项可以同时用于这两个变量，所以仅在最后讲述只能用于其中一个变量的选 项。[提醒]下面所列选项皆为非默认选项，你只要按需添加即可。</p><h3 id="LDFLAGS"><a href="#LDFLAGS" class="headerlink" title="LDFLAGS"></a>LDFLAGS</h3><p>ld用于指定链接时参数</p><h3 id="gcc参数解释"><a href="#gcc参数解释" class="headerlink" title="gcc参数解释"></a>gcc参数解释</h3><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><ul><li>c   编译</li><li>Wall 最常用到的编译警告, 推荐总是使用该选项</li><li>o  小写字母o指定结果文件名称</li><li>l  链接库。编译器选项“-lNAME”试图链接标准库目录下的文件名为“libNAME.a”。lm =&gt; libm.a;  </li><li>I  指定头文件搜索路径</li><li>L  库搜索路径</li><li>static 使用静态库</li><li>ansi禁止那些与 ANSI/ISO 标准冲突的 GNU 扩展特性。在使用 GNU C 库(glibc) 的系统上，该选项也禁止了对 C 标准库的扩展。</li><li>std  指定标准, c89,c99,gnu99,gnu89</li><li>W常见潜在编程错误，建议开发时使用</li></ul><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><ul><li>D  -DNAME选项在命令行上定义预处理宏 NAME</li><li>E 预处理源文件</li></ul><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><ul><li>g 存储额外的调试信息</li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul><li>O0 或者无-O选项: 无优化</li><li>O1或者O: 不需要任何速度-空间折衷的最常见形式的优化</li><li>O2、03:更近异步优化</li></ul><h4 id="平台相关"><a href="#平台相关" class="headerlink" title="平台相关"></a>平台相关</h4><ul><li>march=CPU, 速度快，不可移植。–march=pentium4</li></ul><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>一个与共享库链接的可执行文件仅仅包含它用到的函数相关的一个表格，而不是外部函数所在的 对象文件的整个机器码。在可执行文件开始运行以前，外部函数的机器码由操作系统从磁盘上的 该共享库中复制到内存中—-这个过程被称作动态链接</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>LD_LIBRARY_PATH 动态库查找路径</li><li>C_INCLUDE_PATH 头文件查找路径</li><li>LIBRARY_PATH  静态查找路径</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2018/11/13/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/11/13/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<hr><p>title: 使用hexo搭建博客<br>date: 2018-11-13 17:21:37<br>tags:</p><ul><li>hexo<br>categories:</li><li>工具<br>使用github page来托管我们的博客内容。文章的书写格式为markdown。使用hexo完成markdown到html的转换, 使用hexo deploy发布到github page上。</li></ul><h2 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h2><ul><li>markdown</li></ul><p>John Gruber在2004年发明了markdown, markdown易写易读,使用工具可以方便的转换为html等格式。</p><ul><li>github page</li></ul><p>github page提供静态页面服务, 程序员不仅可以分享代码, 还可以写技术文章。</p><ul><li>hexo</li></ul><p>nodejs开发的工具，用来把markdown转换为html静态网站</p><h2 id="hexo安装步骤"><a href="#hexo安装步骤" class="headerlink" title="hexo安装步骤"></a>hexo安装步骤</h2><ul><li>安装nodejs <code>brew install nodejs</code></li><li>安装hexo <code>npm i -g hexo</code></li><li>初始化根目录 <code>mkdir blog &amp;&amp; cd blog &amp;&amp; hexo init</code></li><li>安装git部署插件 <code>npm install hexo-deployer-git --save</code></li><li>切换主题(可选)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/wzpan/hexo-theme-freemind.git themes/freemind &amp;&amp; \</span><br><span class="line">npm install hexo-tag-bootstrap --save &amp;&amp; \</span><br><span class="line">npm install hexo-generator-search --save &amp;&amp; \</span><br><span class="line">npm install hexo-recommended-posts --save</span><br></pre></td></tr></table></figure></li></ul><p>修改_config.yml, 切换主题 <code>sed -i &#39;s/^theme:.*/theme: freemind/g&#39; _config.yml</code></p><h2 id="hexo-使用步骤"><a href="#hexo-使用步骤" class="headerlink" title="hexo 使用步骤"></a>hexo 使用步骤</h2><p>创建文章（正式文章或者草稿，使用markdown工具进行书写，书写完成后转换为html格式后进行发布。在书写工程中也可以在执行<code>hexo gen &amp;&amp; hexo server</code>后访问localhost:4000预览效果。</p><h2 id="命令参考"><a href="#命令参考" class="headerlink" title="命令参考"></a>命令参考</h2><ul><li>创建草稿 <code>hexo new draft 标题</code></li><li>发布草稿成为正式文章 <code>hexo publish 标题</code></li><li>创建正式文章 <code>hexo new 标题</code></li><li>使用文本工具进行写作, 如使用<code>vim编辑 vim 标题</code></li><li>转换markdown到静态文件 <code>hexo gen</code></li><li>预览网站效果 <code>hexo server</code></li><li>发布到github page <code>hexo deploy</code></li><li>清空生成文件 <code>hexo clean</code></li></ul><h2 id="hexo部署方案"><a href="#hexo部署方案" class="headerlink" title="hexo部署方案"></a>hexo部署方案</h2><p>我希望markdown源文件和hexo生成的静态文件完全隔离。可以方便随时切换主题甚至工具，我只关心源markdown文件。所以设置两个仓库，一个保存hexo生成的html, 一个包含源markdown文件及配置文件。使用ln建立链接。算是linux下的kiss原则吧。我使用 <a href="https://github.com/zhoupro/blog" target="_blank" rel="noopener">blog</a>和<a href="https://github.com/zhoupro/zhoupro.github.io" target="_blank" rel="noopener">zhoupro.github.io</a> 来搭建博客。</p><h2 id="简化流程"><a href="#简化流程" class="headerlink" title="简化流程"></a>简化流程</h2><p><a href="https://github.com/zhoupro/blog" target="_blank" rel="noopener">blog</a>中的init.sh脚本把以上步骤自动化, 执行 <code>. ./init.sh</code>后直接写作即可。</p><h2 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h2><p>参考上传图片到github，创建自己的github仓库，然后配置下脚本 <code>curl https://gist.githubusercontent.com/zhoupro/e09657196114420d63218ebe77079d05/raw/c6d3bd4d8d3dc342813ae37de4e3aed652f9ac30/sh -o genUrl.sh &amp;&amp; bash genUrl.sh yourpic</code>。你也可以上传到第三方服务，使用它们生成的链接。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>valgrind生成调用链</title>
      <link href="/2018/11/12/valgrind%E7%94%9F%E6%88%90%E8%B0%83%E7%94%A8%E9%93%BE/"/>
      <url>/2018/11/12/valgrind%E7%94%9F%E6%88%90%E8%B0%83%E7%94%A8%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="valgrind查看调用关系"><a href="#valgrind查看调用关系" class="headerlink" title="valgrind查看调用关系"></a>valgrind查看调用关系</h2><p>在学习开源代码时，我们希望有个工具能够给我们全局的视角而不过早的陷入细节的泥淖中。读书可以跳读，读代码也是可以跳读的。valgrind可以生成整个调用关系链。该关系链指导我们，迅速定位到我们关心的细节。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>ubuntu系统<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install valgrind </span><br><span class="line">apt-get install kcachegrind</span><br></pre></td></tr></table></figure></p><p>mac系统<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install qcachegrind --with-graphviz</span><br></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>使用valgrind生成调用关系</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=callgrind --trace-children=yes  --callgrind-out-file=/data/opt/callgrind.out.1111  ./nginx</span><br></pre></td></tr></table></figure><ul><li>使用qcachegrind查看调用关系</li></ul><p><img src="https://raw.githubusercontent.com/zhoupro/images/master/20181112/qcachegrind.png" alt="qcachegrind" title="qcachegrind"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>Error: can not open cache simulation output file<br>保证写的目录有写的权限，可以创建一个目录，赋值为777，在该目录下启动命令<code>valgrind --tool=callgrind --trace-children=yes /data/server/nginx/sbin/nginx</code>, 使用kill终止程序<code>kill SIGINT pid</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> valgrind </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>blog purpose</title>
      <link href="/2018/11/06/blog/"/>
      <url>/2018/11/06/blog/</url>
      
        <content type="html"><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>从2014年开始就折腾自己的个人博客，断断续续，从现在开始使用github来写自己的个人博客，用来记录自己的学习过程，把博客和折腾分开。专心学习。</p>]]></content>
      
      
      <categories>
          
          <category> 目标 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
